#!/usr/bin/env python
from lib import *
from  argparse import ArgumentTypeError, ArgumentParser
import re, time
from Bio import AlignIO
from collections import defaultdict
import numpy as np
from pyevolve import GPopulation, GSimpleGA
from pyevolve import Selectors
from pyevolve import Statistics
from pyevolve import DBAdapters
from pyevolve import Consts
from distutils import spawn
from heapq import heappop
from functools import partial
import scipy.stats as ss

expected_nuc = set(['N', 'A', 'T', 'C', 'G'])
global BEST_IND, AVG_IND, WORST_IND
BEST_IND, AVG_IND, WORST_IND = [], [], []

class Output(object):
    
    def __init__(self, file=None):
        if(file):
            out = open(file, 'w')
            self.out = out
        else:
            self.out = sys.stdout

    def write(self, line):
        self.out.write('%s\n' % line)

    def close(self):
        if self.out is not sys.stdout:
            self.out.close()

    @staticmethod
    def error(message):
        sys.stderr.write("Error: %s\n" % message)
        sys.exit(1)


def change_leaf_name(tree, specmap):
    for leaf in tree:
        for s, genes in specmap.items():
            if leaf.name in genes:
                leaf.name  = s
                break
    return tree

def get_trees(treefile, specmap=None, correct=False, ignore_dup=False):
    """Get list of trees from file"""
    trees_list = []
    with open(treefile, 'r') as T:
        current_info = None
        for l in T:
            can_add = True
            l = l.strip()
            if l and not l.startswith('>'):
                t = TreeClass(l)
                if ignore_dup:
                    for other_t in trees_list:
                        rf = t.robinson_foulds(other_t)
                        if rf[0] == 0:
                            can_add = False
                            break
                if can_add:
                    trees_list.append(t)
    if correct and specmap:
        for t in trees_list:
            t = change_leaf_name(t, specmap)
    return trees_list

def is_nuc_align(aln):
    """Check if aln can be passed as nuc alignment"""
    for srec in aln:
        if (set(srec.seq) - expected_nuc):
            return False        
    return True

def check_binaries(binlist=['raxmlHPC-SSE3','raxml']):
    found = False
    for b in binlist:
        if spawn.find_executable(b):
            return b, True
    return None, False


def timeit(func):

    def timed(*args, **kw):
        tstart = time.time()
        result = func(*args, **kw)
        tend = time.time()
        ttime = tend - tstart
        #print '%r (%r, %r) %2.2f sec' % (func.__name__, args, kw, ttime)
        return ttime, result

    return timed 

@timeit
def perform_perm(treelist, raxmlmod, specmap, treelimit=5, timelimit=None):
    tlim = None
    if timelimit and isinstance(timelimit, float):
        tlim = int(timelimit*60)
    trees = Utils.best_tree_finder(treelist, raxmlmod, specmap, treelimit, tlim)
    return [heapop(trees) for i in range(len(trees))]


def evolve_ga(treelist, raxmlmod, specmap, ngen, popsize, freqstat, hasleaf=False, timelimit=None, step=False, verbose=False, termcrit=None):
    genomes = [GPolySolver(x, raxmlmod, is_init=hasleaf) for x in treelist]
    GPolySolver.setGeneMap(specmap)
    gpop = GPopulation.GPopulation(genomes, single=False)
    
    ga = GSimpleGA.GSimpleGA(gpop)# Set the Roulette Wheel selector method, the number of generations and
    # the termination criteria
    
    ga.selector.set(selectors[args.selector])
    ga.setGenerations(ngen)
    ga.setSortType(Consts.sortType["raw"])
    ga.setPopulationSize(popsize)
    if timelimit and isinstance(timelimit, float):
        ga.setMaxTime(int(args.timelim*60))
    
    if termcrit:
        ga.terminationCriteria.set(termcrit)
    else:
        ga.terminationCriteria.set(GSimpleGA.ConvergenceCriteria)

    if step or verbose:
        ga.stepCallback.set(partial(stepcallback, verbose))

    # Sets the DB Adapter, the resetDB flag will make the Adapter recreate
    # the database and erase all data every run, you should use this flag
    # just in the first time, after the pyevolve.db was created, you can
    # omit it.
    
    #sqlite_adapter = DBAdapters.DBSQLite(identify="aae", resetDB=True)
    #ga.setDBAdapter(sqlite_adapter)

    ga.evolve(freq_stats=freqstat)
    return ga


def buildconsensus(treelist):
    # build consensus of a tree list
    return NotImplemented

def randomly_split(gpop, selection):
    part1 = np.random.choice(selection, len(selection)/2, replace=False)
    part2 = set(selection) - set(part1)
    part2 = [gpop[i] for i in part2]
    part1 = [gpop[i] for i in part1]
    if len(selection) % 2 != 0 :
        part2 = part2[:-1]
    return part1, part2
    
def terminate_crit_fc(loop, thres, ga_engine):
    iloop = args.get('loop', 100)
    thresh = args.get('thres', 0.8)
    gpop =  ga_engine.getPopulation()
    popsize = gpop.popSize 
    selection = range(popsize)
    acc = 0
    for i in xrange(iloop):
        part1, part2 = randomly_split(gpop, selection)
        corr = ss.pearsonr([x.score for x in part1], [x.score for x in part2])
        if abs(corr[0]) > thresh:
            acc += 1
    return acc >= iloop - 1


def terminate_crit_wc(loop, thres, ga_engine):
    # cs101 ==> lazy prgramming, copy pasta
    iloop = args.get('loop', 100)
    thresh = args.get('thres', 0.2)
    gpop =  ga_engine.getPopulation()
    popsize = gpop.popSize 
    selection = range(popsize)
    acc = 0
    for i in xrange(iloop):
        part1, part2 = randomly_split(gpop, selection)
        tree1 = buildconsensus(part1)
        tree2 = buildconsensus(part2)
        rf = tree1.robinson_foulds(tree2)
        if rf[0]/rf[1] < thresh:
            acc += 1 
    return acc >= iloop - 1


def terminate_crit_mean(ga_engine):
    # convergence based on distance between mean and max
    stat = ga_engine.getStatistics()
    best_ind = stat['rawMax']
    avg_ind = stat['rawAve']
    worst_ind = stat['rawMin']
    return NotImplemented
   
def terminate_crit_sh_test(known_best, alpha, ga_engine):
    # convergence based on distance between mean and max
    ga_engine.ga.bestIndividual()
    curtree = bestInd.tree
    raxmlmod = bestInd.model
    bestlk, treelk, sucess = raxmlmod.compute_lik_test(known_best, curtree, alpha=alpha)
    if sucess:
        return True
    return False    

def terminate_crit_conv(thresh, ga_engine):
    # convergence based on distance between mean and maxbest 
    global WORST_IND
    if len(WORST_IND) < 2:
        return False
    else:
        return abs(WORST_IND[-1] - WORST_IND[-2]) <= abs(thresh)    

def stepcallback(verbose, ga_engine):
    global BEST_IND, AVG_IND, WORST_IND
    cur_best = ga_engine.bestIndividual()
    stat = ga_engine.getStatistics()
    BEST_IND.append(cur_best.getRawScore())
    WORST_IND.append(stat['rawMin'])
    AVG_IND.append(stat['rawAve'])
    if verbose:
        print("\nCurrent generation : %d"% ga_engine.currentGeneration)
        print("Population size : %d"% len(ga_engine.internalPop))
        print("Best individual score : %f"%  stat['rawMax'])
        print("Worst individual score : %f"%  stat['rawMin'])
        print("Average individual score : %f"%  stat['rawAve'])
        print("Std individual score : %f"%  stat['rawDev'])
    return False  

def print_output(treelist, outfile):
    outlog = Output("%s" % (outfile)) if outfile is not None else Output()
    for i, (tree, score) in enumerate(treelist):
        outlog.write('>tree %d lkl=%.3f\n%s'%(i, score, tree.write()))
    
# ------------------   TEST  fn  ----------------------

def shuffle_map(gmap):
    for k,v in gmap.items():
        np.random.shuffle(v)
    return gmap


def fake_initialize(tree, gmap):
    gmap = shuffle_map(gmap)
    pos = {}
    for node in tree:
        node.add_features(species=node.name)
        pos[node.species] = pos.get(node.species, 0)
        node.name =  gmap[node.species][pos[node.species]]
        pos[node.species] += 1
    return tree


@timeit
def test_model(t, rmod):
    return rmod.optimize_model(t)   

def float01(arg):
    try:
        f = float(arg)
        if f < 0 or f > 1:
            raise ValueError()
    except:
        raise ArgumentTypeError("'" + arg + "' is not a float in range(0,1)")
    return f
    

#------------ main function -----------------

if __name__ == '__main__':
    
    fmtchoice = ("fasta", "stockholm", "clustal", "nexus", "maf", "phylip")
    selectors = {'roulette': Selectors.GRouletteWheel, 
                'tournament' : Selectors.GTournamentSelector, 
                'rank': Selectors.GRankSelector,
                'uniform': Selectors.GUniformSelector}
    parser = ArgumentParser(prog='gaperm', description=DESC, version=VERSION)

    parser.add_argument('--input', '-t', dest="trees", required=True, help="file containing the trees in profileNJ output format")
    parser.add_argument('--aln', '-s', dest="align", required=True, help="A sequence alignment file")
    parser.add_argument('--alnfmt', '-f', dest="fmt", default="fasta", choices=fmtchoice, help="The file format of the sequence alignment. The alignment is assumed to be in fasta format by default")
    parser.add_argument('--smap', '-S', dest="smap",  help="Gene to species map. Use the standard format.")
    parser.add_argument('--sep', dest='genesep', help="Gene-Specie separator for each leaf name in the genetree. This is an alternative for the --smap option")
    parser.add_argument('--spos', dest='spos', default="prefix", help="The position of the specie name according to the separator.")
    parser.add_argument('--cap', dest='cap',  action='store_true', help="Capitalize the species name of the genetree leaves to match each species. Almost all functions are case sensitive.")
    parser.add_argument('--corleaf',  dest='corleaf', action="store_true", help="Change tree name to species")
    parser.add_argument('--ignoredup', action="store_true", help="Check for duplicated trees and ignore them. This is useless when option --corleaf is used.")
    parser.add_argument('--output', '-o', dest='output', help="Output file in which best trees should be saved")
    parser.add_argument('--model', '-m', dest='raxmlmodel', help="Raxml model to use. If you do not provide this, it will guess your sequence type and use either GTRGAMMA or PROTGAMMALG")
    parser.add_argument('--eps',  dest='raxmleps', default=2.0, type=float, help="Raxml eps to use for likelihood computation")
    parser.add_argument('--extras',  dest='raxmlextra', default="", help="Raxml extra arguments")
    parser.add_argument('--timelim', nargs='?', type=float, const=120, help="Set time limit in minutes")
   
    galgo = parser.add_argument_group('Genetic algo', 'Use genetic algorithm to find the best permutation')
    galgo.add_argument('--gen', type=int, default=10, dest='ngen', help="Number of generations for the G.A.")
    galgo.add_argument('--popsize', type=int, default=0, dest='popsize', help="Genetic population size")
    galgo.add_argument('--freqrep', type=int, default=2, help="Number of generation before stat report")
    galgo.add_argument('--selector',  dest='selector', default="roulette", choices=selectors.keys(), help="Selector at each generation")
    galgo.add_argument('--besttree',  dest='mltree', help="Path to known best tree, given the sequences data")
    galgo.add_argument('--verbose', action="store_true", help="Print GA status at each step")
    galgo.add_argument('--stopcrit', dest="stopcrit", default="CONV", choices=('CONV', 'FC', 'WC', 'SH', 'MEAN'), help="Stopping criterion")
    galgo.add_argument('--alpha', default=0.05, type=float01, help="Alpha to use for the SH stopping criterion. Should be a float in ]0,1[")
    galgo.add_argument('--cthresh', default=0.99, type=float01, help="Threshold for WC and FC stopping criterion, Should be a float in ]0,1[")
    galgo.add_argument('--cloop', default=100, type=int, help="Number of iteration for WC and FC stopping criterion")
    galgo.add_argument('--deltalkl', default=1, type=float, help="Maximum difference of score for CONV stopping criterion")
    galgo.add_argument('--plot_lkl', action='store_true', help="Plot best ind likelihood for each generation")

    permalgo = parser.add_argument_group('All permutation', 'Test all possibility for all input trees')
    permalgo.add_argument('--allsearch', nargs='?', const=1, help="Perform all permutation on all input and return best trees. You can specifiy the number of trees you want.")
        

    args = parser.parse_args()
    fmt = args.fmt if args.fmt != 'phylip' else "phylip-relaxed" 
    aln = AlignIO.read(args.align, format=fmt)
    aln_ids = [seqrec.id for seqrec in aln]
    
    specmap = defaultdict(list)
    if(args.smap):
        regexmap = {}
        with open(args.smap, 'rU') as INPUT: 
            for line in INPUT:
                g, s = line.strip().split()
                if ('*') in g and '.*' not in g:
                        g = g.replace('*', '.*')
                g_regex = re.compile(g, re.IGNORECASE)
                regexmap[g_regex] = s
            for gname in aln_ids:
                for reg, spec in regexmap.iteritems():
                    if reg.match(gname):
                        specmap[spec].append(gname)

    elif args.genesep:
        for gname in aln_ids:
            parts = gname.split(args.genesep)
            specname = None
            if args.spos == 'prefix':
                specname = parts[0]
            else:
                specname = parts[-1]

            if args.cap:
                specname.capitalize()
            
            specmap[specname].append(gname)
    
    if not specmap:
        raise ValueError("Mapping between species and genename is empty")

    model = args.raxmlmodel
    if not args.raxmlmodel:
        model = "GTRGAMMA" if is_nuc_align(aln) else "PROTGAMMALG"
    
    treelist = get_trees(args.trees, specmap, correct=(args.corleaf or args.allsearch), ignore_dup=args.ignoredup)
    btype, status = check_binaries()
    if status :
        raxmlmod = LklModel(aln, btype, model, args.raxmleps,extra_string=args.raxmlextra)
    else:
        raxmlmod = RAxMLModel(aln, model, args.raxmleps, extra_string=args.raxmlextra)

    if args.allsearch :
        time, res = perform_perm(treelist, raxmlmod, specmap, args.allsearch, args.timelim)
        print "time : %f , bestscore : %f" %(time, res[-1][0])
    
    else:
        # stopping criterion management
        step = False
        besttree = args.mltree
        if args.stopcrit == 'CONV':
            step = True
        elif args.stopcrit == 'SH':
            if not besttree:
                raise ArgumentError("Best ML tree not found for SH stopping criterion")
            else:
                besttree = TreeClass(besttree)

        stopping = {'CONV' :  partial(terminate_crit_conv, args.deltalkl),
            'FC' :  partial(terminate_crit_fc, args.cloop, args.cthresh),
            'WC' : partial(terminate_crit_wc, args.cloop, args.cthresh),
            'SH' : partial(terminate_crit_sh_test, besttree, args.alpha),
            'MEAN' : terminate_crit_mean
        }
        if not args.popsize:
            args.popsize=len(treelist)
    
        if args.popsize < 0 or args.ngen <0:
            raise ValueError("PopSize and Number of generation should be positive integer")

        ga = evolve_ga(treelist, raxmlmod, specmap, args.ngen,\
                     args.popsize, args.freqrep, (not args.corleaf), args.timelim, args.verbose, termcrit=stopping.get(args.stopcrit, None)) 
        #print ga.bestIndividual()

        if args.plot_lkl:
            import matplotlib.pyplot as plt
            try:
                import seaborn as sns
                sns.set_style("darkgrid")
            except:
                pass  
            print 'BEST_IND',  BEST_IND
            print 'AVG_IND',  AVG_IND
            print 'WORST_IND',  WORST_IND
             
            plt.plot(np.array([BEST_IND, AVG_IND, WORST_IND]).T)
            plt.show()

    
    
        

        